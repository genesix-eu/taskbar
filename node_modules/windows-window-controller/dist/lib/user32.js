'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const ffi = require('ffi');
const ref = require('ref');
const win32_api_1 = require('win32-api');
const Config = require('./types');
const H = require('./helper');
const user32 = win32_api_1.U.load();
exports.taskConfig = {
    tno: 0,
    task: new Map(),
};
exports.enumWindowsProc = ffi.Callback(win32_api_1.windef.BOOL, [win32_api_1.windef.HWND, win32_api_1.windef.LPARAM], (hWnd, lParam) => {
    const task = exports.taskConfig.task.get(lParam);
    /* istanbul ignore if  */
    if (!task) {
        console.error('enumWindowsProc() task not exists');
        return true;
    }
    switch (task.matchType) {
        case 'pid': {
            const buf = ref.alloc(win32_api_1.windef.HINSTANCE);
            const tid = user32.GetWindowThreadProcessId(hWnd, buf);
            /* istanbul ignore else */
            if (tid) {
                const pid = buf.readUInt32LE(0);
                if (pid && pid === task.matchValue) {
                    // console.log('got by pid:', pid, 'hWnd:' + ref.address(hWnd), ref.address(hWnd).toString(16));
                    task.hwndSet.add(hWnd);
                }
            }
            else {
                const lastErrMsg = H.get_last_err_msg();
                if (lastErrMsg) {
                    task.errMsg += ',' + lastErrMsg;
                }
            }
            break;
        }
        case 'title':
            /* istanbul ignore else */
            if (task.matchValue) {
                const buf = Buffer.alloc(254);
                const len = user32.GetWindowTextW(hWnd, buf, 254);
                if (len) {
                    const name = buf.toString('ucs2');
                    // const visible = user32.IsWindowVisible(hWnd);
                    if (name.indexOf(task.matchValue) !== -1) {
                        const buf = Buffer.alloc(4);
                        user32.GetWindowThreadProcessId(hWnd, buf);
                        task.pidSet.add(buf.readUIntLE(0, 4));
                        task.hwndSet.add(hWnd);
                    }
                }
                else {
                    const lastErrMsg = H.get_last_err_msg();
                    if (lastErrMsg) {
                        task.errMsg += ',' + lastErrMsg;
                    }
                }
            }
            else {
                task.hwndSet.add(hWnd);
            }
            break;
        case 'hwnd':
            if (+task.matchValue === ref.address(hWnd)) {
                task.hwndSet.add(hWnd);
            }
            break;
        /* istanbul ignore next */
        default:
            return true;
    }
    return true;
});
function validate_cmdshow(nCmdShow) {
    const res = (typeof nCmdShow !== 'number' || nCmdShow < 0) ? false : true;
    if (!res) {
        console.error('hWnd value invalid: See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms633548(v=vs.85).aspx');
    }
    return res;
}
exports.validate_cmdshow = validate_cmdshow;
function show_hide_one(hWnd, nCmdShow) {
    return new Promise((resolve, reject) => {
        nCmdShow = +nCmdShow;
        // console.log('show_hide_one: ' + ref.address(hWnd) + ', cmd:' + nCmdShow);
        if (Number.isNaN(nCmdShow) || nCmdShow < 0) {
            return reject('show_hide_one() params nCmdShow invalid: ' + nCmdShow);
        }
        if (nCmdShow === 0) {
            if (!user32.IsWindowVisible(hWnd)) {
                return resolve();
            }
        }
        user32.ShowWindow(hWnd, nCmdShow);
        resolve(hWnd);
    });
}
exports.show_hide_one = show_hide_one;
function task_get_hwnds(task) {
    let t;
    return Promise.race([
        new Promise(resolve => {
            t = setTimeout(() => {
                console.info('task_get_hwnds timeout failed');
                resolve();
            }, 30000); // @HARDCOD
        }),
        _get_hwnds(task),
    ]).then((res) => {
        clearTimeout(t);
        task && exports.taskConfig.task.delete(task.tno);
        if (res && Array.isArray(res) && res.length) {
            return res;
        }
    }).catch(err => {
        clearTimeout(t);
        task && exports.taskConfig.task.delete(task.tno);
        console.error(err);
    });
}
exports.task_get_hwnds = task_get_hwnds;
function _get_hwnds(task) {
    if (task.matchType === null) {
        if (typeof task.matchValue === 'string') {
            task.matchType = 'title';
        }
        else if (typeof task.matchValue === 'number') {
            task.matchType = 'pid';
        }
    }
    switch (task.matchType) {
        case 'pid':
            if (!Number.isSafeInteger(task.matchValue)) {
                return Promise.resolve();
            }
            break;
        case 'title':
            // void
            break;
        case 'hwnd':
            // void
            break;
        /* istanbul ignore next */
        default:
            throw new Error('task.matchType value invalid');
    }
    return get_task_hwnd(task)
        .then(res => {
        return res;
    })
        .catch(err => {
        console.error(err);
        return;
    });
}
function get_task_hwnd(task) {
    return new Promise((resolve, reject) => {
        if (!task) {
            resolve([]);
            return;
        }
        user32.EnumWindows.async(exports.enumWindowsProc, task.tno, (err) => {
            // console.log('get_task_hwnd size:', task.hwndSet.size);
            if (task.errMsg) {
                console.error(task.errMsg);
            }
            resolve(Array.from(task.hwndSet) || []);
        });
    });
}
// get hWnd of main top-level window
function filter_hwnd(arr, opts) {
    opts = Object.assign({}, Config.filterWinRulesDefaults, opts);
    const ids = new Set();
    // console.log('filter_main_hwnd:', arr.length, ref.address(arr[0]));
    for (const hWnd of arr) {
        /* istanbul ignore if  */
        if (ids.has(hWnd)) {
            continue;
        }
        /* istanbul ignore else  */
        if (_filter_hwnd(hWnd, opts)) {
            ids.add(hWnd);
        }
    }
    // console.log('filter_main_hwnd return size', ids.size);
    return [...ids.keys()];
}
exports.filter_hwnd = filter_hwnd;
/**
 * filter none top-level window
 * NOTE: not accurate, IME, MESSAGE windows not be filtered out
 */
function _filter_hwnd(hWnd, opts) {
    let p = user32.GetParent(hWnd);
    // const addr = ref.address(hWnd);
    //console.log('addr: ', addr + ':' + addr.toString(16));
    if (!ref.isNull(p)) {
        return false;
    }
    p = user32.GetWindow(hWnd, 4); // GW_OWNER==4
    /* istanbul ignore else  */
    if (!ref.isNull(p)) {
        return false;
    }
    /* istanbul ignore else  */
    if (!validate_rule_title(hWnd, opts)) {
        return false;
    }
    /* istanbul ignore else  */
    if (!validate_rule_style(hWnd, opts)) {
        return false;
    }
    /* istanbul ignore else  */
    if (!validate_rule_exstyle(hWnd, opts)) {
        return false;
    }
    return true;
}
function validate_rule_title(hWnd, opts) {
    const buf = Buffer.alloc(100);
    user32.GetWindowTextW(hWnd, buf, 50);
    let title = ref.reinterpretUntilZeros(buf, 2).toString('ucs2');
    title && (title = title.trim());
    if (opts.titleExits === true) {
        return title ? true : false;
    }
    else if (opts.titleExits === false) {
        return title ? false : true;
    }
    return true; // 'ignore'
}
function validate_rule_style(hWnd, opts) {
    const GWL_STYLE = -16;
    const dwStyle = win32_api_1.conf._WIN64
        ? user32.GetWindowLongPtrW(hWnd, GWL_STYLE)
        : user32.GetWindowLongW(hWnd, GWL_STYLE);
    //console.log('style:', dwStyle);
    // if (dwStyle <= 0) {
    //     return false;
    // }
    /* istanbul ignore else  */
    if (opts.includeStyle && Number.isSafeInteger(opts.includeStyle)) {
        if ((dwStyle | opts.includeStyle) !== dwStyle) {
            return false;
        }
    }
    /* istanbul ignore else  */
    if (opts.excludeStyle && Number.isSafeInteger(opts.excludeStyle)) {
        if ((dwStyle | opts.excludeStyle) === dwStyle) {
            return false;
        }
    }
    return true;
}
function validate_rule_exstyle(hWnd, opts) {
    const GWL_EXSTYLE = -20;
    const dwExStyle = win32_api_1.conf._WIN64
        ? user32.GetWindowLongPtrW(hWnd, GWL_EXSTYLE)
        : user32.GetWindowLongW(hWnd, GWL_EXSTYLE);
    // console.log('dwExstyle:' + dwExStyle);
    // if (dwExStyle <= 0) {
    //     return false;
    // }
    // if (dwExStyle && ((dwExStyle | WS_EX_TOOLWINDOW) === dwExStyle)) {
    //     return false;
    // }
    /* istanbul ignore else  */
    if (opts.includeExStyle && Number.isSafeInteger(opts.includeExStyle)) {
        if ((dwExStyle | opts.includeExStyle) !== dwExStyle) {
            return false;
        }
    }
    /* istanbul ignore else  */
    if (opts.excludeExStyle && Number.isSafeInteger(opts.excludeExStyle)) {
        /* istanbul ignore else  */
        if ((dwExStyle | opts.excludeExStyle) === dwExStyle) {
            return false;
        }
    }
    return true;
}
function create_task() {
    const tno = ++exports.taskConfig.tno;
    const task = {
        tno,
        matchType: null,
        matchValue: '',
        hwndSet: new Set(),
        pidSet: new Set(),
        errMsg: '',
    };
    exports.taskConfig.task.set(tno, task);
    return task;
}
exports.create_task = create_task;
