'use strict';
/**
 * node-windows-window-controller
 *
 * @author waiting
 * @license MIT
 * @link https://github.com/waitingsong/node-windows-window-controller
 */
Object.defineProperty(exports, '__esModule', { value: true });
const ref = require('ref');
const Win = require('win32-api');
exports.Win = Win;
const win32_api_1 = require('win32-api');
const Config = require('./lib/types');
exports.Config = Config;
const u32 = require('./lib/user32');
var user32_1 = require('./lib/user32');
exports.validate_cmdshow = user32_1.validate_cmdshow;
const isWin32 = process.platform === 'win32';
const plateformError = 'Invalid platform: win32 required';
const user32 = win32_api_1.U.load();
// hide the window(s)
function hide(options) {
    const opts = Object.assign({}, Config.filterWinRulesDefaults, options);
    opts.nCmdShow = 0 /* SW_HIDE */;
    return proxy(opts);
}
exports.hide = hide;
// show or hide the window(s)
function show(options) {
    const opts = Object.assign({}, Config.showFilterRulesDefaults, options);
    if (!opts || (opts.titleExits === null || typeof opts.titleExits !== 'boolean')) {
        opts.titleExits = true;
    }
    return proxy(opts);
}
exports.show = show;
// https://msdn.microsoft.com/en-us/library/windows/desktop/ms633548(v=vs.85).aspx
function proxy(opts) {
    const execRet = init_execret();
    if (typeof opts.nCmdShow === 'undefined' || !u32.validate_cmdshow(opts.nCmdShow)) {
        execRet.err = 1;
        execRet.msg = 'value of nCmdShow invalid';
        return Promise.resolve(execRet);
    }
    return get_hwnds(opts).then(hWnds => {
        if (hWnds && hWnds.length) {
            for (const hWnd of hWnds) {
                if (hWnd && !ref.isNull(hWnd)) {
                    // console.log('hWnd addr:', ref.address(hWnd));
                    u32.show_hide_one(hWnd, opts.nCmdShow)
                        .then((hWnd) => hWnd && !ref.isNull(hWnd) && execRet.hwnds.push(ref.address(hWnd)))
                        .catch((err) => {
                        execRet.err = 1;
                        execRet.msg += '\n ' + err;
                    });
                }
            }
        }
    })
        .catch(err => {
        execRet.err = 1;
        execRet.msg += err.toString();
    })
        .then(() => execRet);
}
/**
 * retrieve hWnds by matchValue matched by pid|title
 */
function get_hwnds(opts) {
    // console.log('opts:', opts);
    const task = u32.create_task();
    task.matchType = opts.matchType;
    task.matchValue = opts.matchValue;
    return u32.task_get_hwnds(task)
        .then((arr) => {
        if (arr && Array.isArray(arr) && arr.length) {
            return u32.filter_hwnd(arr, opts);
        }
    });
}
exports.get_hwnds = get_hwnds;
// kill process matched by pid|title, ExecRet.pids contains processed pid
function kill(opts) {
    const execRet = init_execret();
    if (opts.matchType === 'pid') {
        const pid = +opts.matchValue;
        if (pid <= 0) {
            execRet.err = 1;
            execRet.msg = 'pid value invalid';
            return Promise.resolve(execRet);
        }
        _kill(pid);
        execRet.pids.push(pid);
        return Promise.resolve(execRet);
    }
    else if (opts.matchType === 'title') {
        return new Promise(resolve => {
            const task = u32.create_task();
            task.matchType = opts.matchType;
            task.matchValue = opts.matchValue;
            return u32.task_get_hwnds(task).then(() => {
                if (task.pidSet.size) {
                    for (let pid of task.pidSet) {
                        if (_kill(pid)) {
                            execRet.pids.push(pid);
                        }
                    }
                }
                else {
                    execRet.msg = 'the pid list to be killed empty, none title matched';
                }
                resolve(execRet);
            });
        });
    }
    else {
        execRet.err = 1;
        execRet.msg = 'kill() matchType invalid';
        return Promise.resolve(execRet);
    }
}
exports.kill = kill;
function _kill(pid) {
    try {
        process.kill(pid, 0) && process.kill(pid);
        return true;
    }
    catch (ex) {
        console.error(ex);
    }
    return false;
}
function init_execret() {
    return {
        err: 0,
        msg: '',
        pids: [],
        hwnds: [],
    };
}
// retrive hWnd buffer from decimal/hex value of hWnd
function retrieve_pointer_by_hwnd(hwnd) {
    const task = u32.create_task();
    task.matchType = 'hwnd';
    task.matchValue = hwnd;
    return u32.task_get_hwnds(task)
        .then(arr => {
        if (arr && arr.length) {
            return arr[0];
        }
    });
}
exports.retrieve_pointer_by_hwnd = retrieve_pointer_by_hwnd;
function parse_cli_opts(argv) {
    const opts = Object.assign({}, Config.showFilterRulesDefaults);
    if (argv.pid) {
        opts.matchType = 'pid';
        opts.matchValue = +argv.pid;
    }
    else if (argv.title) {
        opts.matchType = 'title';
        opts.matchValue = argv.title;
    }
    else if (argv.hwnd) {
        opts.matchType = 'hwnd';
        opts.matchValue = argv.hwnd;
    }
    else {
        return;
    }
    if (typeof argv.status !== 'undefined') {
        opts.nCmdShow = +argv.status;
        console.assert(typeof opts.nCmdShow === 'number', 'nCmdShow must typeof number');
    }
    return opts;
}
exports.parse_cli_opts = parse_cli_opts;
// user32.SetWindowTextW()
function set_title(title, opts) {
    const execRet = init_execret();
    return get_hwnds(opts).then(hWnds => {
        const buf = Buffer.from(title.trim() + '\0', 'ucs2');
        if (hWnds && hWnds.length) {
            for (const hWnd of hWnds) {
                if (hWnd && !ref.isNull(hWnd)) {
                    user32.SetWindowTextW(hWnd, buf);
                    execRet.hwnds.push(ref.address(hWnd));
                }
            }
        }
    })
        .catch(err => {
        execRet.err = 1;
        execRet.msg += err.toString();
    })
        .then(() => execRet);
}
exports.set_title = set_title;
exports.default = show;
