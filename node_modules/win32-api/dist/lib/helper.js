'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const ffi = require('ffi');
const Conf = require('./conf');
const dllInst = new Map(); // for DLL.load() with settings.singleton === true
function get_inst_by_name(dllName) {
    return dllInst.get(dllName);
}
function set_inst_by_name(dllName, inst) {
    dllInst.set(dllName, inst);
}
function parse_settings(settings) {
    const st = Object.assign({}, Conf.settingsDefault);
    if (typeof settings !== 'undefined' && settings && Object.keys(settings).length) {
        Object.assign(st, settings);
    }
    return st;
}
function load(dllName, apiDef, fns, settings) {
    const st = parse_settings(settings);
    if (st && st.singleton) {
        let inst = get_inst_by_name(dllName);
        if (!inst) {
            inst = ffi.Library(dllName, gen_api_opts(apiDef, fns, st));
            set_inst_by_name(dllName, inst);
        }
        return inst;
    }
    else {
        return ffi.Library(dllName, gen_api_opts(apiDef, fns, st));
    }
}
exports.load = load;
// generate function definitions via converting macro windows data type (like PVOID) to the expected value
function gen_api_opts(apiDef, fns, settings) {
    let opts = {};
    if (fns && Array.isArray(fns) && fns.length) {
        for (let fn of fns) {
            const ps = apiDef[fn];
            if (ps) {
                Object.defineProperty(opts, fn, {
                    value: parse_placeholder(ps, settings),
                    writable: false,
                    enumerable: true,
                    configurable: false,
                });
            }
        }
    }
    else {
        for (let fn of Object.keys(apiDef)) {
            const ps = apiDef[fn];
            Object.defineProperty(opts, fn, {
                value: parse_placeholder(ps, settings),
                writable: false,
                enumerable: true,
                configurable: false,
            });
        }
    }
    return opts;
}
exports.gen_api_opts = gen_api_opts;
function parse_placeholder(ps, settings) {
    if (!ps || !Array.isArray(ps) || ps.length !== 2) {
        throw new Error('parse_placeholder(ps) value of ps invalid');
    }
    const returnParam = ps[0];
    const callParams = ps[1];
    let res = new Array(2);
    // return param
    res[0] = parse_param_placeholder(returnParam, settings);
    // callling params
    // [ [placeholder, string, string],  [placeholder, string, string], string]
    let targetParams = new Array();
    for (let i = 0, len = callParams.length; i < len; i++) {
        targetParams[i] = parse_param_placeholder(callParams[i], settings);
    }
    res[1] = targetParams;
    return res;
}
exports.parse_placeholder = parse_placeholder;
// convert typeof array of param to string such like ['_WIN64_HOLDER_', 'int64', 'int32'], no changed returning when string
function parse_param_placeholder(param, settings) {
    const st = parse_settings(settings);
    if (typeof param === 'string') {
        return param;
    }
    else if (!param || !Array.isArray(param) || param.length !== 3) {
        throw new Error('parse_param_placeholder(ps, settings) value of ps invalid');
    }
    let p = '';
    switch (param[0]) {
        case Conf._WIN64_HOLDER:
            p = parse_placeholder_arch(param, st._WIN64);
            break;
        case Conf._UNICODE_HOLDER:
            p = parse_placeholder_unicode(param, st._UNICODE);
            break;
        default:
            throw new Error('the value of param placeholder invlaid:' + param[0]);
    }
    return p;
}
exports.parse_param_placeholder = parse_param_placeholder;
// convert param like ['_WIN64_HOLDER_', 'int64', 'int32] to 'int64' or 'int32'
function parse_placeholder_arch(param, _WIN64) {
    if (typeof param === 'string') {
        return param;
    }
    else if (!param || param.length !== 3) {
        throw new Error('_WIN64 macro should be Array and has 3 items');
    }
    return _WIN64 ? param[1] : param[2];
}
exports.parse_placeholder_arch = parse_placeholder_arch;
// convert param like ['_UNICODE_HOLDER_', 'uint16*', 'uint8*'] to 'uint16*' or 'uint8*'
function parse_placeholder_unicode(param, _UNICODE) {
    if (typeof param === 'string') {
        return param;
    }
    else if (!param || param.length !== 3) {
        throw new Error('_UNICODE macro should be Array and has 3 items');
    }
    return _UNICODE ? param[1] : param[2];
}
exports.parse_placeholder_unicode = parse_placeholder_unicode;
// convert macro variable of windef
function parse_windef(W, settings) {
    const ww = (settings && settings._windefClone ? clone_filter_windef(W) : W);
    const macroMap = W.macroMap;
    const windef = {};
    const skipKeys = Conf.windefSkipKeys;
    const macroSrc = prepare_macro(macroMap, settings);
    for (let [k, v] of macroSrc.entries()) {
        if (typeof ww[k] !== 'undefined' && v) {
            ww[k] = v;
        }
    }
    prepare_windef_ref(ww);
    for (let x of Object.keys(ww)) {
        if (Conf.windefSkipKeys.has(x)) {
            continue;
        }
        windef[x] = ww[x]; // value processed by prepare_windef_ref() above
    }
    return windef;
}
exports.parse_windef = parse_windef;
function prepare_macro(macroMap, settings) {
    const res = new Map();
    for (let [k, v] of macroMap.entries()) {
        res.set(k, parse_param_placeholder(v, settings));
    }
    return res;
}
// parse const HANDLE = 'PVOID' to the realy FFIParam
function prepare_windef_ref(ww) {
    for (let x of Object.keys(ww)) {
        if (Conf.windefSkipKeys.has(x)) {
            continue;
        }
        const v = ww[x];
        if (typeof v === 'string' && !Conf.windefSet.has(v)) {
            if (typeof ww[v] === 'string') {
                // HANDLE == 'PVOID' , PVOID already parsed
                ww[x] = ww[v];
            }
        }
    }
}
// filter windef by Conf.windefSkipKeys, output only need key/value
function clone_filter_windef(windef) {
    const res = {};
    const skip = Conf.windefSkipKeys;
    for (let x of Object.keys(windef)) {
        if (Conf.windefSkipKeys.has(x)) {
            continue;
        }
        Object.defineProperty(res, x, {
            value: windef[x],
            writable: true,
            enumerable: true,
            configurable: true,
        });
    }
    return res;
}
exports.clone_filter_windef = clone_filter_windef;
